#pragma kernel FluidSimulationCS
#pragma kernel InitCS
#pragma kernel FluidBuildGridCS

#include "FluidParticle.hlsl"

#define tx 64

int _FluidParticleCount;
float _ParticleRadius;
float _FluidDeltaTime;
float _EnergyDumping;
float _SmoothRadius;

uint _PrevFluidParticleCount;
uint _CurrFluidParticleCount;
StructuredBuffer<FluidParticlePhysics> _FluidParticleInit;
RWStructuredBuffer<FluidParticlePhysics> _FluidParticlePhysics;

Texture2D<float> _FluidDensity;
Texture2D<float4> _FluidPressure;
float4 _TexelSize;

[numthreads(tx,1,1)]
void FluidBuildGridCS (uint3 id : SV_DispatchThreadID)
{
	const uint idx = id.x;
	if(idx > _FluidParticleCount) return;

	float yCount = floor(1 / _SmoothRadius);
	float xCount = floor((_TexelSize.x / _TexelSize.y) / _SmoothRadius);
	
	float2 particlePos = _FluidParticlePhysics[idx].position.xy * 0.5 + 0.5;
	particlePos.y = 1 -  particlePos.y;
	int pGridIDX = floor(particlePos.x * xCount);
	int pGridIDY = floor(particlePos.y * yCount);
	int gID = floor(pGridIDX + pGridIDY * (xCount+1));

	_FluidParticlePhysics[idx].gridID = gID;
}

[numthreads(tx,1,1)]
void FluidSimulationCS (uint3 id : SV_DispatchThreadID)
{
	const uint idx = id.x;
	if(idx > _FluidParticleCount) return;
	
	// Update Acceleration
	float2 uv = _FluidParticlePhysics[idx].position.xy * 0.5f + 0.5f;
	uv.y = 1 - uv.y;
	uv.x *= _TexelSize.x;
	uv.y *= _TexelSize.y;
	uint2 uvIndex = floor(uv);
	
	float density = _FluidDensity[uvIndex.xy];
	float2 pressure = _FluidPressure[uvIndex.xy].xy;
	float3 acceleration = 0;
	acceleration.xy = pressure/ max(density, 1e-5);
	acceleration.y *= -1;
	_FluidParticlePhysics[idx].acceleration = acceleration;
	
	// Update Position
	float3 velocity = _FluidParticlePhysics[idx].velocity + acceleration * _FluidDeltaTime;
	float3 position = _FluidParticlePhysics[idx].position + velocity * _FluidDeltaTime;

	float halfBoundSize = 1.f - _ParticleRadius;
	if(abs(position.x) > halfBoundSize)
	{
		position.x = halfBoundSize * sign(position.x);
		velocity.x *= -1;
	}
	
	if(abs(position.y) > halfBoundSize)
	{
		position.y = halfBoundSize * sign(position.y);
		velocity.y *= -1;
	}
	
	_FluidParticlePhysics[idx].color = float4(pressure.xy,0,1);
	_FluidParticlePhysics[idx].position = position;
	_FluidParticlePhysics[idx].velocity = velocity * _EnergyDumping;
}


[numthreads(tx,1,1)]
void InitCS (uint3 id : SV_DispatchThreadID)
{
	const uint idx = id.x;
	if(idx > _CurrFluidParticleCount) return;
	if(idx < _PrevFluidParticleCount) return;
	
	_FluidParticlePhysics[idx].index = _FluidParticleInit[idx].index;
	_FluidParticlePhysics[idx].position = _FluidParticleInit[idx].position;
	_FluidParticlePhysics[idx].velocity = _FluidParticleInit[idx].velocity;
	_FluidParticlePhysics[idx].acceleration = _FluidParticleInit[idx].acceleration;
	_FluidParticlePhysics[idx].color = _FluidParticleInit[idx].color;
}